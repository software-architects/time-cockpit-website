---
layout: blog
title: Proof of Concept Itemized Call List Import
author: Simon Opelt
bannerimage: 
permalink: /2010/07/29/Proof-of-Concept-Itemized-Call-List-Import
---

<p xmlns="http://www.w3.org/1999/xhtml">In our very successfull webinar this morning we were asked by an attendee if it is possible to import phone calls from a mobile network provider's itemized call list. We really liked the idea (thanks <a href="http://grasgruen.it/" target="_blank">grasgruen.it</a>) and decided to create a prototype/proof of concept implementation ofÂ  such an import using <a href="http://ironpython.net/" target="_blank">IronPython</a>, our own SDK and third party APIs.</p><p xmlns="http://www.w3.org/1999/xhtml">The script imports itemized call logs created by <a href="http://www.a1.net/" target="_blank">A1</a>. We looked at export files from other providers and the script should be customized to their (very similar) formats within minutes. The basic steps involved are:</p><ul xmlns="http://www.w3.org/1999/xhtml">
  <li>Import required references.</li>
  <li>Load the CSV file using a <a href="http://www.codeproject.com/KB/database/CsvReader.aspx" target="_blank">third party library</a>.</li>
  <li>For each CSV line analyze the content.</li>
  <li>If the line corresponds to a phone call or short message create an time cockpit <span class="InlineCode">EntityObject</span>.</li>
  <li>Collect all the call/short message entity objects.</li>
  <li>Filter the list of calls/short message to prevent duplicate imports (by looking at which ranges of data are already available).</li>
  <li>Store the data.</li>
</ul><p class="InfoBox" xmlns="http://www.w3.org/1999/xhtml">Please be aware that the script uses some non-public interfaces which may change in the future. It is only a way of enabling this use case until more platforms are supported by the call log import signal tracker or native mobile clients.</p><f:function name="Composite.Web.Html.SyntaxHighlighter" xmlns:f="http://www.composite.net/ns/function/1.0">
  <f:param name="SourceCode" value="# CONFIGURE!&#xA;fileName = &quot;C:\\Temp\\Kostenabfrage.csv&quot;&#xA;&#xA;# imports and references&#xA;clr.AddReference(&quot;System.Core&quot;)&#xA;clr.AddReference(&quot;TimeCockpit.UI.Common&quot;)&#xA;clr.AddReference(&quot;TimeCockpit.SignalStorage&quot;)&#xA;clr.AddReference(&quot;LumenWorks.Framework.IO&quot;)&#xA;from System import DateTime, TimeSpan&#xA;from System.Collections.Generic import List&#xA;from System.Globalization import CultureInfo&#xA;from System.IO import StreamReader&#xA;from System.Linq import Enumerable&#xA;from TimeCockpit.UI.Common import *&#xA;from TimeCockpit.SignalStorage import SignalStorageManager&#xA;from LumenWorks.Framework.IO.Csv import CsvReader&#xA;&#xA;# determine lineage&#xA;currentDeviceId = TimeCockpitApplication.Current.ApplicationSettings.DeviceId&#xA;lineage = Context.SelectSingleWithParams({ &quot;Query&quot;: &quot;From L In SignalLineage Where L.Device.DeviceUuid = @DeviceUuid Order By L.BeginTime Desc Select L&quot;, &quot;@DeviceUuid&quot;: currentDeviceId })&#xA;&#xA;# parse EGN file&#xA;calls = List[EntityObject]()&#xA;messages = List[EntityObject]()&#xA;&#xA;streamReader = None&#xA;csv = None&#xA;linesToSkip = 3&#xA;&#xA;try:&#xA;    streamReader = StreamReader(fileName)&#xA;    while linesToSkip &gt; 0:&#xA;        streamReader.ReadLine()&#xA;        linesToSkip -= 1&#xA;&#xA;    csv = CsvReader(streamReader, False, ';')&#xA;&#xA;    while csv.ReadNextRecord():&#xA;        entryType = csv[7]&#xA;        if entryType == &quot;TEL&quot;:&#xA;            call = Context.CreateCleansedPhoneCallSignal()&#xA;&#xA;            call.BeginTime = DateTime.ParseExact(csv[4], &quot;dd.MM.yyyy&quot;, CultureInfo.InvariantCulture).Add(TimeSpan.Parse(csv[5], CultureInfo.InvariantCulture))&#xA;            if csv[13] == &quot;ankommend&quot;:&#xA;                call.Direction = &quot;Incoming&quot;&#xA;                call.PhoneNumber = &quot;&quot;&#xA;            else:&#xA;                call.Direction = &quot;Outgoing&quot;&#xA;                call.PhoneNumber = csv[13]&#xA;&#xA;            call.EndTime = call.BeginTime.Add(TimeSpan.Parse(csv[8], CultureInfo.InvariantCulture))&#xA;            call.Finalized = True&#xA;            call.RemoteParty = &quot;&quot;&#xA;            call.Lineage = lineage&#xA;            calls.Add(call)&#xA;            &#xA;        elif entryType == &quot;SMS&quot;:&#xA;            message = Context.CreateCleansedShortMessageSignal()&#xA;&#xA;            message.Direction = &quot;Outgoing&quot;&#xA;            message.EventTime = DateTime.ParseExact(csv[4], &quot;dd.MM.yyyy&quot;, CultureInfo.InvariantCulture).Add(TimeSpan.Parse(csv[5], CultureInfo.InvariantCulture))&#xA;            message.Finalized = True&#xA;            message.PhoneNumber = csv[13]&#xA;            message.RemoteParty = &quot;&quot;&#xA;            message.Subject = &quot;&quot;&#xA;            message.Lineage = lineage&#xA;            messages.Add(message)&#xA;&#xA;finally:&#xA;    if not csv == None:&#xA;        csv.Dispose()&#xA;    if not streamReader == None:&#xA;        streamReader.Dispose()&#xA;&#xA;# filter signals to prevent duplicate imports&#xA;query = &quot;From C In Chunk Where C.Device.DeviceUuid = @DeviceUuid And C.Entity.EntityName = @SignalEntityName Select New With { .MinBeginTime = Min(C.BeginTime), .MaxEndTime = Max(C.EndTime) }&quot;&#xA;callSignalDates = Context.SelectSingleWithParams({ &quot;Query&quot;: query, &quot;@DeviceUuid&quot;: currentDeviceId , &quot;@SignalEntityName&quot;: &quot;APP_CleansedPhoneCallSignal&quot; })&#xA;messageSignalDates = Context.SelectSingleWithParams({ &quot;Query&quot;: query, &quot;@DeviceUuid&quot;: currentDeviceId , &quot;@SignalEntityName&quot;: &quot;APP_CleansedShortMessageSignal&quot; })&#xA;&#xA;if callSignalDates.MinBeginTime != None:&#xA;    calls = Enumerable.ToList(Enumerable.Where(calls, lambda c: c.BeginTime &gt; callSignalDates.MaxEndTime or c.EndTime &lt; callSignalDates.MinBeginTime ))&#xA;if messageSignalDates.MinBeginTime != None:&#xA;    messages = Enumerable.ToList(Enumerable.Where(messages, lambda m: m.EventTime &gt; messageSignalDates.MaxEndTime or m.EventTime &lt; messageSignalDates.MinBeginTime ))&#xA;&#xA;# store signals&#xA;ssm = SignalStorageManager(Context)&#xA;&#xA;if calls.Count &gt; 0:&#xA;    ssm.Store(calls)&#xA;    print &quot;Imported&quot;, calls.Count, &quot;phone calls&quot;&#xA;else:&#xA;    print &quot;No phone calls imported&quot;&#xA;&#xA;if messages.Count &gt; 0:&#xA;    ssm.Store(messages)&#xA;    print &quot;Imported&quot;, messages.Count, &quot;short messages&quot;&#xA;else:&#xA;    print &quot;No short messages imported&quot;&#xA;&#xA;print &quot;done.&quot;" xmlns:f="http://www.composite.net/ns/function/1.0" />
  <f:param name="CodeType" value="c#" xmlns:f="http://www.composite.net/ns/function/1.0" />
</f:function><p xmlns="http://www.w3.org/1999/xhtml">During the creation of the script we became aware of several limitations of this approach compared to our phone import signal tracker (which uses a call log exported from the phone) or future native phone clients/signal trackers:</p><ul xmlns="http://www.w3.org/1999/xhtml">
  <li>No caller name is provided.</li>
  <li>Phone numbers are trimmed for privacy reasons.</li>
  <li>Only outgoing calls/messages (and incoming roaming calls) are tracked.</li>
</ul><p xmlns="http://www.w3.org/1999/xhtml">Please note that the execution of this script could also be <a href="http://help.timecockpit.com/html/7c78b76a-2526-4408-accc-ccae19bbca45.htm" target="_blank">automated</a>.</p><p xmlns="http://www.w3.org/1999/xhtml">Comments, questions or suggestions are highly appreciated.</p>