---
layout: blog
title: BIG DAYS 2011 - Parallel Programming 
author: Rainer Stropek
bannerimage: 
permalink: /2011/03/28/BIG-DAYS-2011---Parallel-Programming-
---

<p xmlns="http://www.w3.org/1999/xhtml">At the BIG&gt;DAYS 2011, the largest roadshow of Microsoft in Austria with approx. 1,700 visitors, I do a session about parallel programming together with Andreas Schabus. In the session we start with the basics of parallel programming in .NET 4 and C# 4. Based on that we discuss the importance of parallel programming in Windows Azure and do demos for scaling out compute tasks into the cloud as well as a demo for parallel querying using the concept of horizontal sharding in the SQL Azure database layer.</p><p xmlns="http://www.w3.org/1999/xhtml">If you are interested in the slides, <a href="{{site.baseurl}}/images/blog/2011/03/BigDays 2011_Parallel Data Processing On Premise und in der Cloud FINAL.pdf" target="_blank">here they are</a> (unfortunately only available in German; however, samples are international by nature).</p><p xmlns="http://www.w3.org/1999/xhtml">Today I found the time to record the introductory demo of the talk (my cat forced me to keep sitting in front of my computer by laying down on my lap so I had some minutes of "spare" time). If you are interested here is the video of the demo. If you are wondering what's the difference between tasks and threads in .NET 4 or you just want to get into parallel programming it could help.</p><iframe width="480" height="390" title="YouTube video player" src="https://www.youtube.com/embed/r1FbKiHYHcw" frameborder="0" xmlns="http://www.w3.org/1999/xhtml"></iframe><h2 xmlns="http://www.w3.org/1999/xhtml">Step 1 - Performing a task in background</h2>{% highlight javascript}Action&lt;Action&gt; measure = (body) =&gt;{ &#xA;  var startTime = DateTime.Now; &#xA;  body(); &#xA;  Console.WriteLine(&quot;{0} {1}&quot;, Thread.CurrentThread.ManagedThreadId, DateTime.Now - startTime); &#xA;}; &#xA;&#xA;Action calcProcess = () =&gt; { for (int i = 0; i &lt; 350000000; i++);}; &#xA;&#xA;measure(() =&gt;{ &#xA;  var tasks = new[] { &#xA;    Task.Factory.StartNew(() =&gt; measure(calcProcess)), &#xA;    […] &#xA;    Task.Factory.StartNew(() =&gt; measure(calcProcess)) &#xA;  }; &#xA;&#xA;  Task.WaitAll(tasks); &#xA;}); {% endhighlight javascript }<p xmlns="http://www.w3.org/1999/xhtml">You can write the last line of code much cleaner:</p>{% highlight javascript}measure(() =&gt; { &#xA;  Task.WaitAll(Enumerable.Range(0, 10) &#xA;  .Select(_ =&gt; Task.Factory.StartNew(() =&gt; measure(calcProcess))) &#xA;  .ToArray()); &#xA;});{% endhighlight javascript }<p xmlns="http://www.w3.org/1999/xhtml">Still a lot of code. It is much easier like this:</p>{% highlight javascript}Parallel.For(0, 10, _ =&gt; { measure(calcProcess); });{% endhighlight javascript }<h2 xmlns="http://www.w3.org/1999/xhtml">Step 2 - Perform IO-bound tasks instead of parallel calculations</h2><p xmlns="http://www.w3.org/1999/xhtml">Take the first sample and simulate IO bound tasks instead of parallel calculations. You will see that TPL behaves differently (see videos for details):</p>{% highlight javascript}Action&lt;Action&gt; measure = (body) =&gt;{ &#xA;  var startTime = DateTime.Now; &#xA;  body(); &#xA;  Console.WriteLine(&quot;{0} {1}&quot;, Thread.CurrentThread.ManagedThreadId, &#xA;  DateTime.Now - startTime); &#xA;}; &#xA;&#xA;Action calcProcess = () =&gt; { for (int i = 0; i &lt; 350000000; i++);}; &#xA;Action ioProcess = () =&gt; { Thread.Sleep(1000); }; &#xA;&#xA;measure(() =&gt;{ &#xA;  Task.WaitAll(Enumerable.Range(0, 10) &#xA;  .Select(_ =&gt; Task.Factory.StartNew(() =&gt; measure(ioProcess))) &#xA;  .ToArray()); &#xA;});{% endhighlight javascript }<p xmlns="http://www.w3.org/1999/xhtml">Behind the scenes tasks are still using the good old thread pool. You can see that if you play around with the thread pool size (be very careful with that in real projects; think about writing your own scheduler if you really full control):</p>{% highlight javascript}ThreadPool.SetMinThreads(5, 5); &#xA;measure(() =&gt;{ &#xA;  Task.WaitAll(Enumerable.Range(0, 10) &#xA;  .Select(_ =&gt; Task.Factory.StartNew(() =&gt; measure(ioProcess))) &#xA;  .ToArray()); &#xA;});{% endhighlight javascript }<h2 xmlns="http://www.w3.org/1999/xhtml">Step 3 - Use PLINQ instead of TPL</h2><p xmlns="http://www.w3.org/1999/xhtml">PLINQ makes parallel programming sometimes easier. Check out how you could use it in the previous sample:</p>{% highlight javascript}measure(() =&gt; Enumerable.Range(0, 10)&#xA;  .AsParallel() &#xA;  .ForAll(_ =&gt; measure(ioProcess)));{% endhighlight javascript }<p xmlns="http://www.w3.org/1999/xhtml">Note that you can write this much shorter:</p>{% highlight javascript}measure(() =&gt; ParallelEnumerable.Range(0, 10) &#xA;  .ForAll(_ =&gt; measure(ioProcess)));{% endhighlight javascript }<p xmlns="http://www.w3.org/1999/xhtml">You can also control the degree of parallelism:</p>{% highlight javascript}measure(() =&gt; ParallelEnumerable.Range(0, 10) &#xA;  .WithDegreeOfParallelism(5) &#xA;  .ForAll(_ =&gt; measure(ioProcess)));{% endhighlight javascript }<h2 xmlns="http://www.w3.org/1999/xhtml">Step 4 - Data structures for parallel programming</h2><p xmlns="http://www.w3.org/1999/xhtml">Note that the following implementation of a producer/consumer pattern is TOTALLY WRONG because the old collections are not thread safe (there are many more mistakes in the following code so do not use it!!).</p>{% highlight javascript}var queue = new Queue&lt;int&gt;(100); &#xA;&#xA;var producers = Enumerable.Range(1, 5) &#xA;  .Select(i =&gt; Task.Factory.StartNew(() =&gt; &#xA;  { &#xA;    var rand = new Random(); &#xA;    for (int counter = 0; counter &lt; 100; counter++) &#xA;    { &#xA;      queue.Enqueue(rand.Next(1000000)); // WRONG because queue is not thread safe&#xA;      Thread.Sleep(100); &#xA;    } &#xA;  })) &#xA;  .ToArray(); &#xA;&#xA;var consumers = Enumerable.Range(1, 3) &#xA;  .Select(i =&gt; Task.Factory.StartNew(() =&gt; &#xA;  { &#xA;    while(true) &#xA;    { &#xA;      while (queue.Count == 0) &#xA;      { &#xA;        Thread.Sleep(100); &#xA;      } &#xA;      Console.WriteLine(queue.Dequeue()); // WRONG because queue is not thread safe&#xA;    } &#xA;  })) &#xA;  .ToArray(); &#xA;&#xA;Task.WaitAll(producers.Concat(consumers).ToArray());{% endhighlight javascript }<p xmlns="http://www.w3.org/1999/xhtml">With the new concurrent data structures from .NET 4 implementing producer/consumer patterns in parallel is a piece of cake:</p>{% highlight javascript}var queue = new BlockingCollection&lt;int&gt;(100); &#xA;&#xA;var producers = Enumerable.Range(1, 5) &#xA;  .Select(i =&gt; Task.Factory.StartNew(() =&gt; &#xA;  { &#xA;    var rand = new Random(); &#xA;    for (int counter = 0; counter &lt; 100; counter++) &#xA;    { &#xA;      queue.Add(rand.Next(1000000)); &#xA;      Thread.Sleep(100); &#xA;    } &#xA;  })) &#xA;  .ToArray(); &#xA;&#xA;var consumers = Enumerable.Range(1, 3) &#xA;  .Select(i =&gt; Task.Factory.StartNew(() =&gt; &#xA;  {  &#xA;    foreach(var item in queue.GetConsumingEnumerable()) &#xA;    { &#xA;      Console.WriteLine(item); &#xA;    } &#xA;  })) &#xA;  .ToArray(); &#xA;&#xA;Task.WaitAll(producers); &#xA;queue.CompleteAdding(); &#xA;Task.WaitAll(consumers); {% endhighlight javascript }