---
layout: blog
title: C# Parallel and Async Programming
author: Rainer Stropek
bannerimage: 
permalink: /2014/09/22/C-Parallel-and-Async-Programming
---

<p xmlns="http://www.w3.org/1999/xhtml">At BASTA 2014 I will do a <a href="http://www.software-architects.com/devblog/2014/09/21/BASTA-2014-C-Fitness" target="_blank">full-day C# workshop</a>. One of the topics will be parallel and async programming. In this blog article I share the code of my demo and describe the scenario I will cover: TPL, async/await, profiling of CPU-bound algorithms.</p><h2 xmlns="http://www.w3.org/1999/xhtml">The Scenario</h2><p xmlns="http://www.w3.org/1999/xhtml">The sample scenario is one that I used multiple times before: Calculating PI using a <a href="http://en.wikipedia.org/wiki/Monte_Carlo_method" target="_blank">Monte Carlo Simulation</a>. However, for the BASTA workshop I have completely rewritten the sample code. I also included some demos for upcoming C# 6 features.</p><p class="showcase" xmlns="http://www.w3.org/1999/xhtml">You can download the entire sample from <a href="https://github.com/rstropek/Samples/tree/master/ProfilingWorkshop" target="_blank">my GitHub Samples repository</a>.</p><p xmlns="http://www.w3.org/1999/xhtml">Let's start with a trivial, synchronous implementation. During the workshop, I put it in a portable class library as I will use the sample to speak about PCLs and NuGet, too. But this is a topic for another blog article ...</p>{% highlight javascript}using System;&#xA;#if LANG_EXPERIMENTAL&#xA;// Note c# 6 using static here&#xA;using System.Math;&#xA;#endif&#xA;&#xA;namespace PiWithMonteCarlo&#xA;{&#xA;&#x9;/// &lt;summary&gt;&#xA;&#x9;/// Trivial, synchronous calculation algorithm&#xA;&#x9;/// &lt;/summary&gt;&#xA;    public static class TrivialPiCalculator&#xA;    {&#xA;&#x9;&#x9;public static double Calculate(int iterations)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int inCircle = 0;&#xA;&#x9;&#x9;&#x9;var random = new Random();&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; iterations; i++)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;var a = random.NextDouble();&#xA;&#x9;&#x9;&#x9;&#x9;var b = random.NextDouble();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Strictly speaking, we do not need Sqrt here. We could simply drop it and still get the&#xA;&#x9;&#x9;&#x9;&#x9;// same result. However, this sample should demonstrate some perf topics, too. Therefore&#xA;&#x9;&#x9;&#x9;&#x9;// it stays there just so the program has to do some math.&#xA;#if LANG_EXPERIMENTAL&#xA;&#x9;&#x9;&#x9;&#x9;var c = Sqrt(a * a + b * b);&#xA;#else&#xA;&#x9;&#x9;&#x9;&#x9;var c = Math.Sqrt(a * a + b * b);&#xA;#endif&#xA;&#x9;&#x9;&#x9;&#x9;if (c &lt;= 1)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;inCircle++;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;return ((double)inCircle / iterations) * 4;&#xA;&#x9;&#x9;}&#xA;    }&#xA;}{% endhighlight javascript }<p xmlns="http://www.w3.org/1999/xhtml">For comparing the performance of the different calculation algorithms we add a command line test driver:</p>{% highlight javascript}using System;&#xA;using System.Diagnostics;&#xA;&#xA;namespace PiWithMonteCarlo.TestDriver&#xA;{&#xA;&#x9;class Program&#xA;&#x9;{&#xA;&#x9;&#x9;static void Main(string[] args)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;var iterations = 20000000 * Environment.ProcessorCount;&#xA;&#xA;&#x9;&#x9;&#x9;ExecuteAndPrint(&quot;Trivial PI Calculator&quot;, TrivialPiCalculator.Calculate, iterations);&#xA;&#x9;&#x9;&#x9;ExecuteAndPrint(&quot;\n(Stupid) Parallel.For PI Calculator&quot;, ParallelForPiCalculator.Calculate, iterations);&#xA;&#x9;&#x9;&#x9;ExecuteAndPrint(&quot;\nParallel.For PI Calculator&quot;, EnhancedParallelForPiCalculator.Calculate, iterations);&#xA;&#x9;&#x9;&#x9;ExecuteAndPrint(&quot;\nPLinq PI Calculator&quot;, PlinqPiCalculator.Calculate, iterations);&#xA;&#x9;&#x9;&#x9;ExecuteAndPrint(&quot;\nFast PI Calculator&quot;, FastPiCalculator.Calculate, iterations);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private static void ExecuteAndPrint(string label, Func&lt;int, double&gt; calculation, int iterations)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;Console.WriteLine(label);&#xA;&#x9;&#x9;&#x9;PrintResult(Measure(() =&gt; calculation(iterations)), iterations);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private static void PrintResult(Tuple&lt;double, TimeSpan&gt; r, int iterations)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;Console.WriteLine(&#xA;&#x9;&#x9;&#x9;&#x9;&quot;{0} ({1:#,##0.0000} sec for {2:#,##0} iterations = {3:#,##0.00} iter/sec)&quot;, &#xA;&#x9;&#x9;&#x9;&#x9;r.Item1, &#xA;&#x9;&#x9;&#x9;&#x9;r.Item2.TotalSeconds, &#xA;&#x9;&#x9;&#x9;&#x9;iterations, &#xA;&#x9;&#x9;&#x9;&#x9;iterations / r.Item2.TotalSeconds);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private static Tuple&lt;T, TimeSpan&gt; Measure&lt;T&gt;(Func&lt;T&gt; body)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;var watch = new Stopwatch();&#xA;&#x9;&#x9;&#x9;watch.Start();&#xA;&#x9;&#x9;&#x9;var result = body();&#xA;&#x9;&#x9;&#x9;watch.Stop();&#xA;&#x9;&#x9;&#x9;return new Tuple&lt;T, TimeSpan&gt;(result, watch.Elapsed);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}{% endhighlight javascript }<h2 xmlns="http://www.w3.org/1999/xhtml">Trivial Parallelization</h2><p xmlns="http://www.w3.org/1999/xhtml">TPL contains a useful construct: <em>Parallel.For</em>. It makes it quite simple to turn a sequential for loop into a parallel algorithm. So let's use it in our sample:</p>{% highlight javascript}using System;&#xA;using System.Threading;&#xA;using System.Threading.Tasks;&#xA;&#xA;namespace PiWithMonteCarlo&#xA;{&#xA;&#x9;/// &lt;summary&gt;&#xA;&#x9;/// Very simple implementation with Parallel.For&#xA;&#x9;/// &lt;/summary&gt;&#xA;&#x9;public static class ParallelForPiCalculator&#xA;&#x9;{&#xA;&#x9;&#x9;public static double Calculate(int iterations)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;var randomLockObject = new object();&#xA;&#x9;&#x9;&#x9;int inCircle = 0;&#xA;&#x9;&#x9;&#x9;var random = new Random();&#xA;&#xA;&#x9;&#x9;&#x9;Parallel.For(0, iterations, i =&gt;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;double a, b;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;lock (randomLockObject)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;a = random.NextDouble();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;b = random.NextDouble();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var c = Math.Sqrt(a * a + b * b);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (c &lt;= 1)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Interlocked.Increment(ref inCircle);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;});&#xA;&#xA;&#x9;&#x9;&#x9;return ((double)inCircle / iterations) * 4;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}{% endhighlight javascript }<p xmlns="http://www.w3.org/1999/xhtml">What do you think, does it use all CPU cores? Will it be faster? Try it using our test driver shown above.</p><h2 xmlns="http://www.w3.org/1999/xhtml">Enhanced Parallel.For</h2><p xmlns="http://www.w3.org/1999/xhtml">It turns out that our parallel version uses more CPU but is slower. So we have to enhance it. This could look something like this:</p>{% highlight javascript}using System;&#xA;using System.Collections.Generic;&#xA;using System.Linq;&#xA;using System.Text;&#xA;using System.Threading;&#xA;using System.Threading.Tasks;&#xA;&#xA;namespace PiWithMonteCarlo&#xA;{&#xA;&#x9;/// &lt;summary&gt;&#xA;&#x9;/// Enhanced version of &lt;see cref=&quot;ParallelForPiCalculator&quot;/&gt;.&#xA;&#x9;/// &lt;/summary&gt;&#xA;&#x9;public static class EnhancedParallelForPiCalculator&#xA;&#x9;{&#xA;&#x9;&#x9;public static double Calculate(int iterations)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;var counterLockObject = new object();&#xA;&#x9;&#x9;&#x9;int inCircle = 0;&#xA;&#x9;&#x9;&#x9;var random = new ThreadSafeRandom();&#xA;&#xA;&#x9;&#x9;&#x9;Parallel.For(0, iterations,&#xA;&#x9;&#x9;&#x9;&#x9;// doesn't make sense to use more threads than we have processors&#xA;&#x9;&#x9;&#x9;&#x9;new ParallelOptions() { MaxDegreeOfParallelism = Environment.ProcessorCount }, &#xA;&#x9;&#x9;&#x9;&#x9;() =&gt; 0, (i, _, tLocal) =&gt;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;#if LANG_EXPERIMENTAL&#xA;                        // Note C# 6 declarating expression here&#xA;                        return tLocal += Math.Sqrt((var a = random.NextDouble()) * a &#xA;                            + (var b = random.NextDouble()) * b) &lt;= 1 ? 1 : 0;&#xA;#else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;double a, b;&#xA;                        return tLocal += Math.Sqrt((a = random.NextDouble()) * a + (b = random.NextDouble()) * b) &lt;= 1 ? 1 : 0;&#xA;#endif&#xA;                    },&#xA;&#x9;&#x9;&#x9;&#x9;subTotal =&gt; Interlocked.Add(ref inCircle, subTotal));&#xA;&#xA;&#x9;&#x9;&#x9;return ((double)inCircle / iterations) * 4;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}{% endhighlight javascript }<p xmlns="http://www.w3.org/1999/xhtml">Much better like this, isn't it?</p><h2 xmlns="http://www.w3.org/1999/xhtml">PLINQ</h2><p xmlns="http://www.w3.org/1999/xhtml">During the workshop I show a PLINQ implementation, too. We discuss the different programming styles and check the performance results.</p>{% highlight javascript}using System;&#xA;using System.Collections.Generic;&#xA;using System.Linq;&#xA;using System.Text;&#xA;using System.Threading;&#xA;using System.Threading.Tasks;&#xA;&#xA;namespace PiWithMonteCarlo&#xA;{&#xA;&#x9;/// &lt;summary&gt;&#xA;&#x9;/// Monte carlo written with PLINQ&#xA;&#x9;/// &lt;/summary&gt;&#xA;&#x9;public static class PlinqPiCalculator&#xA;&#x9;{&#xA;&#x9;&#x9;public static double Calculate(int iterations)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;var random = new ThreadSafeRandom();&#xA;&#x9;&#x9;&#x9;var inCircle = ParallelEnumerable.Range(0, iterations)&#xA;&#x9;&#x9;&#x9;&#x9;// doesn't make sense to use more threads than we have processors&#xA;&#x9;&#x9;&#x9;&#x9;.WithDegreeOfParallelism(Environment.ProcessorCount)&#xA;&#x9;&#x9;&#x9;&#x9;.Select(_ =&gt;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;double a, b;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return Math.Sqrt((a = random.NextDouble()) * a + (b = random.NextDouble()) * b) &lt;= 1;&#xA;&#x9;&#x9;&#x9;&#x9;})&#xA;&#x9;&#x9;&#x9;&#x9;.Aggregate&lt;bool, int, int&gt;(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;0, // Seed&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(agg, val) =&gt; val ? agg + 1 : agg, // Iterations&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(agg, subTotal) =&gt; agg + subTotal, // Aggregating subtotals&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;result =&gt; result); // No projection of result needed&#xA;&#xA;&#x9;&#x9;&#x9;return ((double)inCircle / iterations) * 4;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}{% endhighlight javascript }<h2 xmlns="http://www.w3.org/1999/xhtml">Fast Implementation Using Tasks</h2><p xmlns="http://www.w3.org/1999/xhtml">So let's try what we can achieve if we handcraft the tasks ourselves.</p>{% highlight javascript}using System;&#xA;using System.Collections.Generic;&#xA;using System.Linq;&#xA;using System.Text;&#xA;using System.Threading;&#xA;using System.Threading.Tasks;&#xA;&#xA;namespace PiWithMonteCarlo&#xA;{&#xA;&#x9;public static class FastPiCalculator&#xA;&#x9;{&#xA;&#x9;&#x9;public static double Calculate(int iterations)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;var procCount = Environment.ProcessorCount;&#xA;&#x9;&#x9;&#x9;if (iterations % procCount != 0)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;throw new ArgumentException(&quot;Must be a multiple of Environment.ProcessorCount&quot;, &quot;iterations&quot;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// Distribute iterations evenly across processors&#xA;&#x9;&#x9;&#x9;var iterPerProc = iterations / procCount;&#xA;&#xA;&#x9;&#x9;&#x9;// One array slot per processor&#xA;&#x9;&#x9;&#x9;var inCircleLocal = new int[procCount];&#xA;&#x9;&#x9;&#x9;var tasks = new Task[procCount];&#xA;&#x9;&#x9;&#x9;for (var proc = 0; proc &lt; procCount; proc++)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;var procIndex = proc; // Helper for closure&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Start one task per processor&#xA;&#x9;&#x9;&#x9;&#x9;tasks[proc] = Task.Run(() =&gt;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var inCircleLocalCounter = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var random = new Random(procIndex);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var index = 0; index &lt; iterPerProc; index++)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;double a, b;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (Math.Sqrt((a = random.NextDouble()) * a + (b = random.NextDouble()) * b) &lt;= 1)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;inCircleLocalCounter++;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;inCircleLocal[procIndex] = inCircleLocalCounter;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;});&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;Task.WaitAll(tasks);&#xA;&#xA;&#x9;&#x9;&#x9;var inCircle = inCircleLocal.Sum();&#xA;&#x9;&#x9;&#x9;return ((double)inCircle / iterations) * 4;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}{% endhighlight javascript }<p xmlns="http://www.w3.org/1999/xhtml">Go on and compare the different algorithms. Impressed of how much faster the last one is?</p><h2 xmlns="http://www.w3.org/1999/xhtml">Async Programming</h2><p xmlns="http://www.w3.org/1999/xhtml">During the workshop we spend quite some time discussing the difference between parallel and async programming. The following sample algorithm takes the last implementation shown above and converts it to an easy-to-use async method:</p>{% highlight javascript}using System;&#xA;using System.Diagnostics;&#xA;using System.Linq;&#xA;using System.Threading;&#xA;using System.Threading.Tasks;&#xA;&#xA;namespace PiWithMonteCarlo&#xA;{&#xA;#if LANG_EXPERIMENTAL&#xA;    /// &lt;summary&gt;&#xA;    /// Note C# 6 primay constructor and auto-property initializer here&#xA;    /// &lt;/summary&gt;&#xA;&#x9;public class PiCalculatorIntermediateResult(long iterations, double resultPi)&#xA;    {&#xA;&#x9;&#x9;public double ResultPi { get; } = resultPi;&#xA;&#x9;&#x9;public long Iterations { get; } = iterations;&#xA;&#x9;}&#xA;#else&#xA;&#x9;public class PiCalculatorIntermediateResult&#xA;&#x9;{&#xA;        public PiCalculatorIntermediateResult(long iterations, double resultPi)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.Iterations = iterations;&#xA;&#x9;&#x9;&#x9;this.ResultPi = resultPi;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public double ResultPi { get; private set; }&#xA;&#x9;&#x9;public long Iterations { get; private set; }&#xA;&#x9;}&#xA;#endif&#xA;&#xA;    /// &lt;summary&gt;&#xA;    /// Async version of &lt;see cref=&quot;FastPiCalculator&quot;/&gt;.&#xA;    /// &lt;/summary&gt;&#xA;    public class FastPiAsyncCalculator&#xA;&#x9;{&#xA;&#x9;&#x9;public static async Task CalculateAsync(CancellationToken cancellationToken, &#xA;&#x9;&#x9;&#x9;Func&lt;PiCalculatorIntermediateResult, Task&gt; reportIntermediateResultAsyncCallback,&#xA;&#x9;&#x9;&#x9;Func&lt;Task&gt; stoppedCallback)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// Number of iterations after which we check if it is time to report results back to caller&#xA;&#x9;&#x9;&#x9;const long timerCheckInterval = 100000;&#xA;&#xA;&#x9;&#x9;&#x9;// Reserve one thread for UI&#xA;&#x9;&#x9;&#x9;var procCount = Environment.ProcessorCount - 1;&#xA;&#x9;&#x9;&#x9;do&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;var watch = new Stopwatch();&#xA;&#x9;&#x9;&#x9;&#x9;watch.Start();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// One array slot per processor&#xA;&#x9;&#x9;&#x9;&#x9;var inCircleArray = new long[procCount];&#xA;&#x9;&#x9;&#x9;&#x9;var iterationsArray = new long[procCount];&#xA;&#x9;&#x9;&#x9;&#x9;var tasksArray = new Task[procCount];&#xA;&#x9;&#x9;&#x9;&#x9;for (var proc = 0; proc &lt; procCount; proc++)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;var procIndex = proc; // Helper for closure&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Start one task per processor&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tasksArray[proc] = Task.Run(() =&gt;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;long inCircleLocalCounter = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;long iterationsLocalCounter = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;var random = new Random(procIndex);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (var index = 0; true; index++)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;iterationsLocalCounter++;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;double a, b;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (Math.Sqrt((a = random.NextDouble()) * a + (b = random.NextDouble()) * b) &lt;= 1)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;inCircleLocalCounter++;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (index &gt;= timerCheckInterval)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;index = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;lock (watch)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (watch.ElapsedMilliseconds &gt;= 1000)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Every second we stop calculating and report result back&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// public local counters in result array&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;inCircleArray[procIndex] = inCircleLocalCounter;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;iterationsArray[procIndex] = iterationsLocalCounter;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;});&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Wait until all processing tasks are done&#xA;&#x9;&#x9;&#x9;&#x9;await Task.WhenAll(tasksArray).ConfigureAwait(false);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Report result back&#xA;&#x9;&#x9;&#x9;&#x9;var inCircle = inCircleArray.Sum();&#xA;&#x9;&#x9;&#x9;&#x9;var iterations = iterationsArray.Sum();&#xA;&#x9;&#x9;&#x9;&#x9;await reportIntermediateResultAsyncCallback(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;new PiCalculatorIntermediateResult(iterations, ((double)inCircle / iterations) * 4));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;while (!cancellationToken.IsCancellationRequested);&#xA;&#xA;&#x9;&#x9;&#x9;// Report end of calculation back to caller&#xA;&#x9;&#x9;&#x9;await stoppedCallback();&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}{% endhighlight javascript }<p xmlns="http://www.w3.org/1999/xhtml">Based on that, it is easy to add a platform-independent ViewModel implementation (could be used in a e.g. Windows Store app, WPF, etc.).</p>{% highlight javascript}using Microsoft.Practices.Prism.Commands;&#xA;using Microsoft.Practices.Prism.Mvvm;&#xA;using System;&#xA;using System.Diagnostics;&#xA;using System.Threading;&#xA;using System.Threading.Tasks;&#xA;using System.Windows.Input;&#xA;&#xA;namespace PiWithMonteCarlo&#xA;{&#xA;&#x9;/// &lt;summary&gt;&#xA;&#x9;/// Viewmodel that can easily be consumed in XAML-based applications&#xA;&#x9;/// &lt;/summary&gt;&#xA;&#x9;public class FastPiAsyncCalculatorViewModel : BindableBase&#xA;&#x9;{&#xA;&#x9;&#x9;public FastPiAsyncCalculatorViewModel()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.startCommand = new DelegateCommand(&#xA;&#x9;&#x9;&#x9;&#x9;async () =&gt; await this.OnStartCalculation(),&#xA;&#x9;&#x9;&#x9;&#x9;() =&gt; !this.IsCalculating);&#xA;&#xA;&#x9;&#x9;&#x9;this.stopCommand = new DelegateCommand(&#xA;&#x9;&#x9;&#x9;&#x9;this.OnStopCalculation,&#xA;&#x9;&#x9;&#x9;&#x9;() =&gt; this.IsCalculating);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private CancellationTokenSource cts = null;&#xA;&#x9;&#x9;private Stopwatch watch = null;&#xA;&#x9;&#x9;private static Task finishedTask = Task.FromResult(0);&#xA;&#xA;&#x9;&#x9;private async Task OnStartCalculation()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (!this.IsCalculating)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Start calculation&#xA;&#x9;&#x9;&#x9;&#x9;this.IsCalculating = true;&#xA;&#x9;&#x9;&#x9;&#x9;this.watch = new Stopwatch();&#xA;&#x9;&#x9;&#x9;&#x9;this.watch.Start();&#xA;&#x9;&#x9;&#x9;&#x9;this.cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));&#xA;&#x9;&#x9;&#x9;&#x9;await FastPiAsyncCalculator.CalculateAsync(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.cts.Token,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;result =&gt;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Navigate back to UI thread to update notification properties&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SynchronizationContext.Current.Post(new SendOrPostCallback(_ =&gt;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;this.CalcualtedPi = result.ResultPi;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;this.Iterations += result.Iterations;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;this.IterationsPerSecond = (double)this.Iterations / this.watch.Elapsed.TotalSeconds;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}), null);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return FastPiAsyncCalculatorViewModel.finishedTask;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;},&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;() =&gt;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Switch state to not calculating&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;this.IsCalculating = false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return FastPiAsyncCalculatorViewModel.finishedTask;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;});&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private void OnStopCalculation()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (this.IsCalculating)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Cancel calculation&#xA;&#x9;&#x9;&#x9;&#x9;this.cts.Cancel();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;#region Bindable properties&#xA;&#x9;&#x9;private double calculatedPi;&#xA;&#x9;&#x9;public double CalcualtedPi&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get { return this.calculatedPi; }&#xA;&#x9;&#x9;&#x9;private set { SetProperty(ref this.calculatedPi, value); }&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private long iterations;&#xA;&#x9;&#x9;public long Iterations&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get { return this.iterations; }&#xA;&#x9;&#x9;&#x9;private set { SetProperty(ref this.iterations, value); }&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private double iterationsPerSecond;&#xA;&#x9;&#x9;public double IterationsPerSecond&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get { return this.iterationsPerSecond; }&#xA;&#x9;&#x9;&#x9;private set { SetProperty(ref this.iterationsPerSecond, value); }&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private bool isCalculating;&#xA;&#x9;&#x9;public bool IsCalculating&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get { return this.isCalculating; }&#xA;&#x9;&#x9;&#x9;private set &#xA;&#x9;&#x9;&#x9;{ &#xA;&#x9;&#x9;&#x9;&#x9;SetProperty(ref this.isCalculating, value);&#xA;&#x9;&#x9;&#x9;&#x9;this.startCommand.RaiseCanExecuteChanged();&#xA;&#x9;&#x9;&#x9;&#x9;this.stopCommand.RaiseCanExecuteChanged();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;#region Bindable commands&#xA;&#x9;&#x9;private DelegateCommand startCommand;&#xA;&#x9;&#x9;public ICommand StartCommand&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get { return this.startCommand; }&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private DelegateCommand stopCommand;&#xA;&#x9;&#x9;public ICommand StopCommand&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get { return this.stopCommand; }&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;#endregion&#xA;&#x9;}&#xA;}{% endhighlight javascript }<p xmlns="http://www.w3.org/1999/xhtml">Have fun playing around with the code!</p>